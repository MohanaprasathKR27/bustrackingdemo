<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Bus Tracking Prototype (Smooth Animation)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { font-family: Arial, sans-serif; margin: 12px; }
    #map { height: 520px; width: 100%; border: 1px solid #ccc; border-radius: 6px; }
    h2 { margin: 6px 0 12px; }
    .controls { margin: 8px 0; }
    button { padding: 8px 12px; border-radius: 5px; border: none; cursor: pointer; }
  </style>
</head>
<body>
  <h2>üöç Real-Time Bus Tracking ‚Äî Prototype</h2>
  <div class="controls">
    <button id="startBtn">Start Animation</button>
    <button id="resetBtn">Reset</button>
    <span style="margin-left:12px; color:#666">Tip: open on laptop for demo, or host it to share a link.</span>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
  // ----------------------------
  // Configuration
  // ----------------------------
  // default starting view (change to your city coordinates)
  const startView = [12.9716, 77.5946]; // example: Punjab
  const initialZoom = 14;

  // route points (latitude, longitude) - add or replace with your city's route
  const route = [
    [30.3398, 76.3869], // Patiala
    [30.3745, 76.1520], // Nabha
    [30.6450, 76.3841], // Sirhind
  ];

  // pick stop indices from route array (these will show as stops)
  const stopIndices = [0, 1, 2];

  // bus speed in meters/second (adjust to simulate faster/slower bus)
  const BUS_SPEED_MPS = 12; // ~43 km/h

  // ----------------------------
  // Helpers
  // ----------------------------
  // Haversine distance in meters:
  function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = (deg) => deg * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  // Linear interpolation between two latlngs (good enough for short segments)
  function lerp(a, b, t) { return a + (b - a) * t; }

  // ----------------------------
  // Initialize Map
  // ----------------------------
  const map = L.map('map').setView(startView, initialZoom);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '¬© OpenStreetMap contributors',
    maxZoom: 19
  }).addTo(map);

  // draw route polyline
  const poly = L.polyline(route, {color: '#2E86AB', weight: 5, opacity: 0.8}).addTo(map);
  map.fitBounds(poly.getBounds(), {padding: [50,50]});

  // add bus stop markers
  stopIndices.forEach((idx, i) => {
    const latlng = route[idx];
    L.circleMarker(latlng, {radius:6, fill:true, color:'#ff5c5c', fillOpacity:1})
      .addTo(map).bindPopup("Stop " + (i+1));
  });

  // Bus icon (local file 'bus.png' in same folder) with fallback to an online icon if not found
  const busIcon = L.icon({
    iconUrl: 'bus.png.png',
    iconSize: [42, 42],
    iconAnchor: [21, 21]
  });

  // Add marker at the first route point
  let busMarker = L.marker(route[0], {icon: busIcon}).addTo(map).bindPopup("Bus 1");

  // ----------------------------
  // Animation logic
  // ----------------------------
  let animating = false;
  let currentSegment = 0; // index in route: segment = route[currentSegment] -> route[currentSegment+1]
  let rafId = null;
  let segmentStartTime = null;
  let segmentDurationMs = 0;
  let segStartLatLng = null;
  let segEndLatLng = null;

  function startSegment(idx) {
    if (idx >= route.length - 1) {
      console.log('Reached end of route');
      animating = false;
      return;
    }
    currentSegment = idx;
    segStartLatLng = {lat: route[idx][0], lng: route[idx][1]};
    segEndLatLng   = {lat: route[idx+1][0], lng: route[idx+1][1]};
    const dist = haversineDistance(segStartLatLng.lat, segStartLatLng.lng, segEndLatLng.lat, segEndLatLng.lng); // meters
    const durationSec = dist / BUS_SPEED_MPS;
    segmentDurationMs = Math.max(300, Math.round(durationSec * 1000)); // min duration 300ms for very small segments
    segmentStartTime = null;
    // start RAF
    rafId = requestAnimationFrame(step);
  }

  function step(timestamp) {
    if (!segmentStartTime) segmentStartTime = timestamp;
    const elapsed = timestamp - segmentStartTime;
    const t = Math.min(1, elapsed / segmentDurationMs); // progress 0..1

    // interpolate lat/lng
    const lat = lerp(segStartLatLng.lat, segEndLatLng.lat, t);
    const lng = lerp(segStartLatLng.lng, segEndLatLng.lng, t);
    busMarker.setLatLng([lat, lng]);

    // optional: update popup with ETA to next stop
    const remainingDist = haversineDistance(lat, lng, segEndLatLng.lat, segEndLatLng.lng);
    const etaSec = Math.round(remainingDist / BUS_SPEED_MPS);
    busMarker.bindPopup("Bus 1 ‚Äî ETA to next stop: " + etaSec + " s");

    if (t < 1) {
      rafId = requestAnimationFrame(step);
    } else {
      // segment finished - move to next
      currentSegment++;
      if (currentSegment < route.length - 1) {
        // small pause at stops (simulate dwell time)
        setTimeout(() => startSegment(currentSegment), 800);
      } else {
        animating = false;
        console.log('Completed route.');
      }
    }
  }

  function startAnimation() {
    if (animating) return;
    animating = true;
    startSegment(0);
  }

  function resetAnimation() {
    cancelAnimationFrame(rafId);
    animating = false;
    currentSegment = 0;
    busMarker.setLatLng(route[0]);
    busMarker.bindPopup("Bus 1");
  }

  // Buttons
  document.getElementById('startBtn').addEventListener('click', () => startAnimation());
  document.getElementById('resetBtn').addEventListener('click', () => resetAnimation());

  // auto-start for demo when page loads
  // setTimeout(startAnimation, 800);
  </script>
</body>
</html>